<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caesar Cipher & RSA Encryption</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px auto;
            max-width: 2000px;
            padding: 20px;
            color: #333;
            background: #f4f4f9;
        }
        h1 {
            text-align: center;
            color: #444;
        }
        textarea,
        input {
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            background: #fff;
        }
        textarea {
            height: 120px;
        }
        button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            font-size: 16px;
            color: #fff;
            background: #007BFF;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .shift-display {
            text-align: center;
            margin: 10px 0;
            font-size: 18px;
            color: #666;
        }
        .charts-container {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        .chart {
            width: 45%;
        }
        .button_enc{
            display: flex;
        }
    </style>
</head>
<body>
    <h1>Caesar Cipher & RSA Encryption</h1>
    <textarea id="inputText" placeholder="Enter your text here..."></textarea>
    <div class="button_enc">
        <button onclick="encryptText('caesar')">Encrypt Text (Caesar Method)</button>
        <button onclick="encryptText('rsa')">Encrypt Text (RSA)</button>
    </div>

    <div>
        <label for="rsaExponent">RSA Exponent (k):</label>
        <input type="number" id="rsaExponent" value="3" min="1">
    </div>

    <div class="shift-display" id="shiftDisplay">Random Shift: Not Applied Yet</div>
    <textarea id="decodedOutput" placeholder="Decoded text will appear here..." readonly></textarea>
    <select id="decodingMethod" onchange="clearDecodedOutput()">
        <option value="frequency">Frequency Analysis</option>
        <option value="bruteforce">Bruteforce</option>
    </select>
    <button onclick="decodeText()">Decode Text</button>

    <h1>Caesar Cipher Explanation</h1>
    <div class="charts-container">
        <div class="chart">
            <h2>Original Text Frequency</h2>
            <canvas id="originalChart"></canvas>
        </div>
        <div class="chart">
            <h2>Ciphered Text Frequency</h2>
            <canvas id="cipheredChart"></canvas>
        </div>
    </div>

    <script>
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const englishFrequencies = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'; // Ordered by frequency in English
        let shift = 0;
        let originalText = '';
        let cipheredText = '';
        let rsaCipheredText = [];

        let originalChartInstance = null;
        let cipheredChartInstance = null;

        // RSA Encryption Function (M^k % N for each letter)
        function rsaEncryption(text, N, k) {
            const numbers = text.toUpperCase().split('').map(char => {
                if (alphabet.includes(char)) {
                    const index = alphabet.indexOf(char);
                    // Encrypt using RSA formula: M^k % N
                    return Math.pow(index, k) % N;
                }
                return char; // Non-alphabet characters remain unchanged
            });
            console.log("RSA Encrypted Numbers: ", numbers.join(' ')); // Debugging log
            rsaCipheredText = numbers; // Store the encrypted numbers
            return numbers.map(num => alphabet[num % 26]).join(''); // Return encrypted text as letters
        }

        function countFrequencies(text) {
            const frequencies = Array(26).fill(0); // Initialize A-Z with zero frequency
            text.toUpperCase().split('').forEach(char => {
                if (alphabet.includes(char)) {
                    frequencies[alphabet.indexOf(char)]++;
                }
            });
            return frequencies;
        }

        function encryptText(method) {
            originalText = document.getElementById('inputText').value.toUpperCase();
            if (!originalText) {
                alert('Please enter some text!');
                return;
            }
            console.log("Original Text: ", originalText); // Debugging log

            if (method === 'caesar') {
                shift = Math.floor(Math.random() * 26); // Random shift between 0-25
                cipheredText = originalText.split('').map(char => {
                    if (alphabet.includes(char)) {
                        const index = (alphabet.indexOf(char) + shift) % 26;
                        return alphabet[index];
                    }
                    return char; // Non-alphabet characters remain unchanged
                }).join(''); // Cifrato con Cesare
                console.log("Caesar Encrypted Text: ", cipheredText); // Debugging log
                document.getElementById('shiftDisplay').innerText = `Random Shift: ${shift}`;

                // Update charts for Caesar Cipher only
                updateCharts();
            } else if (method === 'rsa') {
                const N = 37;  // Example prime modulus N = 37
                const k = parseInt(document.getElementById('rsaExponent').value) || 3;  // Get RSA exponent
                cipheredText = rsaEncryption(originalText, N, k);
                document.getElementById('shiftDisplay').innerText = `RSA Encryption with N=${N}, k=${k}`;

                // Do not update charts for RSA
            }
        }

        // Function to decode the text
        function decodeText() {
            const decodingMethod = document.getElementById('decodingMethod').value;
            if (!cipheredText) {
                alert('Please encrypt text first!');
                return;
            }
            console.log("Ciphered Text: ", cipheredText); // Debugging log

            let decodedText = '';
            if (decodingMethod === 'frequency') {
                decodedText = decodeWithFrequencyAnalysis();
            } else if (decodingMethod === 'bruteforce') {
                decodedText = decodeWithBruteforce();
            }

            animateDecodedText(decodedText); // Call the animation function after decoding
        }

        function decodeWithFrequencyAnalysis() {
            const cipheredFrequencies = countFrequencies(cipheredText);
            const mostFrequentCipheredIndex = cipheredFrequencies.indexOf(Math.max(...cipheredFrequencies));
            const mostFrequentCipheredLetter = alphabet[mostFrequentCipheredIndex];

            const estimatedShift = (mostFrequentCipheredIndex - alphabet.indexOf('E') + 26) % 26;

            console.log("Frequency Analysis - Estimated Shift: ", estimatedShift); // Debugging log

            return cipheredText.split('').map(char => {
                if (alphabet.includes(char)) {
                    const index = (alphabet.indexOf(char) - estimatedShift + 26) % 26;
                    return alphabet[index];
                }
                return char;
            }).join(''); 
        }

        function decodeWithBruteforce() {
            for (let i = 0; i < 26; i++) {
                const possibleDecryption = cipheredText.split('').map(char => {
                    if (alphabet.includes(char)) {
                        const index = (alphabet.indexOf(char) - i + 26) % 26;
                        return alphabet[index];
                    }
                    return char;
                }).join(''); 
                console.log(`Trying shift ${i}:`, possibleDecryption);
                if (possibleDecryption.toUpperCase().includes('THE')) {
                    return possibleDecryption; // Found a valid shift
                }
            }
            return 'Brute force failed to find a valid decryption.';
        }

        function clearDecodedOutput() {
            document.getElementById('decodedOutput').value = '';
        }

        function updateCharts() {
            const originalFrequencies = countFrequencies(originalText);
            const cipheredFrequencies = countFrequencies(cipheredText);

            if (originalChartInstance) {
                originalChartInstance.destroy();
            }
            if (cipheredChartInstance) {
                cipheredChartInstance.destroy();
            }

            const originalCtx = document.getElementById('originalChart').getContext('2d');
            const cipheredCtx = document.getElementById('cipheredChart').getContext('2d');

            originalChartInstance = new Chart(originalCtx, {
                type: 'bar',
                data: {
                    labels: alphabet.split(''),
                    datasets: [{
                        label: 'Original Frequency',
                        data: originalFrequencies,
                        backgroundColor: '#007BFF',
                        borderColor: '#007BFF',
                        borderWidth: 1
                    }]
                }
            });

            cipheredChartInstance = new Chart(cipheredCtx, {
                type: 'bar',
                data: {
                    labels: alphabet.split(''),
                    datasets: [{
                        label: 'Ciphered Frequency',
                        data: cipheredFrequencies,
                        backgroundColor: '#FF5733',
                        borderColor: '#FF5733',
                        borderWidth: 1
                    }]
                }
            });
        }

        // Animation for decoded text
        function animateDecodedText(decodedText) {
            const decodedTextArea = document.getElementById('decodedOutput');
            let currentIndex = 0;
            decodedTextArea.value = '';

            const interval = setInterval(() => {
                if (currentIndex < decodedText.length) {
                    decodedTextArea.value += decodedText[currentIndex++];
                } else {
                    clearInterval(interval);
                }
            }, 1); // Add text every 100ms
        }

    </script>
</body>
</html>
